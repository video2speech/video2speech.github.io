<!doctype html>
<html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Video Recording Tool</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
  html{width:100%;height:100%;margin:0;padding:0}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;width:100%;margin:0;padding:16px;line-height:1.5;background-color:#1a1a1a;color:#e0e0e0;box-sizing:border-box;min-height:100vh}
  .card{border:1px solid #444;border-radius:12px;padding:16px;margin:16px 0;background-color:#2a2a2a}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  video{width:300px;height:200px;background:#000;border-radius:8px;margin:0 auto;display:block;object-fit:contain}
  .video-mirrored{transform:scaleX(-1)}
  button{padding:10px 14px;border-radius:10px;border:1px solid #555;background:#444;color:#e0e0e0;transition:all 0.1s ease}
  button:active{opacity:.8;transform:scale(0.95)}
  input,textarea,select{width:100%;padding:10px;border-radius:10px;border:1px solid #555;background-color:#333;color:#e0e0e0}
  select{width:auto}
  .big{font-size:1.4rem;font-weight:600;margin:8px 0}
  .muted{color:#666}
  
  .sentence-preparing {
    color: #888;
  }
  
  /* Responsive font sizes for sentences */
  @media (max-width: 768px) {
    #currentText {
      font-size: 3.5rem !important;
      padding: 30px !important;
      min-height: 35vh !important;
    }
  }
  
  @media (min-width: 769px) and (max-width: 1024px) {
    #currentText {
      font-size: 4.5rem !important;
      padding: 45px !important;
      min-height: 40vh !important;
    }
  }
  
  @media (min-width: 1025px) {
    #currentText {
      font-size: 5rem !important;
      padding: 50px !important;
      min-height: 45vh !important;
    }
  }
  
  .sentence-recording {
    color: #4CAF50 !important;
    animation: none;
  }
  
  .button-active {
    transform: scale(0.95);
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
    transition: all 0.1s ease;
  }
  
  .button-pressed {
    background: #222 !important;
    border-color: #666 !important;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
    transform: scale(0.95);
  }
</style>
<body>
  <div class="card">
    <div class="row">
      <label>Select Sentence Set</label>
      <select id="sentenceSet" onchange="loadSentenceSet()">
        <option value="50_repeat6_sentences">50_Repeat6_Sentences</option>
        <option value="300_nonrepeating_sentences" selected>300_Nonrepeating_Sentences</option>
      </select>
      <button id="resetProgress" onclick="resetProgress()" style="margin-left: 8px;">Reset Progress</button>
      <button id="clearProgress" onclick="clearAllProgress()" style="margin-left: 8px;">Clear All Progress</button>
    </div>
    <div class="row" style="display: none;">
      <button id="prev">Previous</button>
      <button id="next">Next</button>
      <button id="skip">Skip</button>
    </div>
    <div class="big sentence-preparing" id="currentText" style="font-size: 4rem; font-weight: bold; text-align: center; padding: 40px; border: 2px solid #555; border-radius: 16px; margin: 24px 0; min-height: 45vh; width: 100%; box-sizing: border-box; display: flex; align-items: center; justify-content: center; position: relative; line-height: 1.3; background-color: #333;">
      <div id="recordingStatus" style="position: absolute; top: 15px; left: 20px; z-index: 15; font-size: 1.5rem; font-weight: bold; color: #888; background: rgba(0, 0, 0, 0.7); padding: 8px 16px; border-radius: 18px; display: none;">Preparing</div>
      <span class="muted" id="idxInfo" style="position: absolute; top: 15px; right: 20px; font-size: 1rem; color: #888; font-weight: normal; text-align: right; white-space: pre-line;"></span>
      Waiting for initialization...
    </div>
  </div>

  <div class="card" style="position: relative; padding: 12px; margin: 12px 0;">
    <video id="preview" playsinline autoplay muted></video>
     <div id="initCameraOverlay" style="position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%); z-index: 10; background: rgba(0, 0, 0, 0.9); padding: 35px; border-radius: 20px; text-align: center; max-width: 750px; width: 90%; box-shadow: 0 8px 32px rgba(0,0,0,0.5);">
       <p style="color: #90EE90; font-size: 2.2rem; margin: 0 0 20px 0; font-weight: 600;">Thank you so much for participating today!</p>
       
       <h3 style="color: white; margin: 0 0 20px 0; font-size: 1.6rem; font-weight: 600;">üìã Instructions:</h3>
       <div style="color: #e0e0e0; font-size: 1.3rem; line-height: 1.4; margin-bottom: 25px; text-align: left;">
         <p style="margin: 15px 0;"><strong style="color: #81C784; margin-right: 8px;">1.</strong> Click <strong style="color: #81C784; background: rgba(129, 199, 132, 0.2); padding: 2px 6px; border-radius: 4px;">"Initialize Camera"</strong>, and Position camera below chin level, angling upward so mouth, throat, and cheeks are visible.</p>
         <p style="margin: 15px 0;"><strong style="color: #64B5F6; margin-right: 8px;">2.</strong> Press <kbd style="background: #333; color: #64B5F6; padding: 4px 8px; border-radius: 6px; font-family: monospace; font-weight: bold;">Space</kbd> key on keyboard to <strong style="color: #64B5F6; background: rgba(100, 181, 246, 0.2); padding: 2px 6px; border-radius: 4px;">start or end recording of each sentence</strong></p>
         <p style="margin: 15px 0;"><strong style="color: #FFB74D; margin-right: 8px;">3.</strong> If you make mistakes in reading the current sentence, you can press <kbd style="background: #333; color: #FFB74D; padding: 4px 8px; border-radius: 6px; font-family: monospace; font-weight: bold;">Space</kbd> to <strong style="color: #FFB74D; background: rgba(255, 183, 77, 0.2); padding: 2px 6px; border-radius: 4px;">end the recording firstly </strong>, then press <kbd style="background: #333; color: #FFB74D; padding: 4px 8px; border-radius: 6px; font-family: monospace; font-weight: bold;">Left Arrow</kbd> to <strong style="color: #FFB74D; background: rgba(255, 183, 77, 0.2); padding: 2px 6px; border-radius: 4px;">redo that sentence</strong></p>
         <p style="margin: 15px 0;"><strong style="color: #BA68C8; margin-right: 8px;">4.</strong> Click <strong style="color: #BA68C8; background: rgba(186, 104, 200, 0.2); padding: 2px 6px; border-radius: 4px;">SAVE ALL</strong> <strong style="color: #BA68C8; background: rgba(186, 104, 200, 0.2); padding: 2px 6px; border-radius: 4px;">after each recording session</strong></p>
       </div>
       <button id="init" style="font-size: 1.4rem; padding: 16px 32px; background: linear-gradient(135deg, #81C784, #66BB6A); color: white; border: none; border-radius: 12px; cursor: pointer; font-weight: 600; box-shadow: 0 4px 15px rgba(129, 199, 132, 0.4); transition: all 0.3s ease;">üì∑ Initialize Camera</button>
     </div>
          <div class="row" style="margin-top:8px; justify-content: center;">
        <button id="start" style="font-size: 1.1rem; padding: 10px 20px; background: #5a6b5a; color: white; border: none; border-radius: 8px; cursor: pointer; margin: 0 6px;">‚ñ∂ Start</button>
        <button id="stop" style="font-size: 1.1rem; padding: 10px 20px; background: #7a5a5a; color: white; border: none; border-radius: 8px; cursor: pointer; margin: 0 6px;">‚è≠ Stop & Next</button>
        <button id="redo" style="font-size: 1.1rem; padding: 10px 20px; background: #7a6b5a; color: white; border: none; border-radius: 8px; cursor: pointer; margin: 0 6px;">üîÑ Redo last</button>
      </div>
      <div class="row" style="margin-top:8px; justify-content: center;">
        <button id="downloadAll" style="font-size: 1.1rem; padding: 10px 20px; background: #5a6b7a; color: white; border: none; border-radius: 8px; cursor: pointer; margin: 0 6px; display:none">üíæ SAVE ALL</button>
      </div>
    <div class="row">
      <button id="clearAll" style="display:none">Clear Storage</button>
    </div>
    <div class="row" style="flex-direction: column; align-items: center; margin-top: 10px;">
      <span class="muted" id="storageInfo" style="font-size: 1rem; margin-bottom: 5px;"></span>
      <div class="row" style="margin-bottom: 5px; align-items: center;">
        <label style="font-size: 0.8rem; color: #888; margin-right: 8px;">Recording Resolution</label>
        <select id="resolution" style="font-size: 0.8rem; padding: 2px 4px;">
          <option value="720p">720p (1280√ó720) - Standard</option>
          <option value="1080p" selected>1080p (1920√ó1080) - Recommended</option>
          <option value="480p">480p (854√ó480) - Standard</option>
          <option value="360p">360p (640√ó360) - Low Quality</option>
          <option value="auto">Auto - Camera Default</option>
        </select>
      </div>
      <div class="row" style="margin-bottom: 5px; align-items: center;">
        <label style="font-size: 0.8rem; color: #888; margin-right: 8px;">
          <input type="checkbox" id="mirrorVideo" checked style="margin-right: 4px;">
          Mirror Video Display
        </label>
      </div>
      <span class="muted" id="resolutionInfo" style="font-size: 0.8rem; color: #888;"></span>
    </div>
    <div class="row">
      <!-- <span class="muted" id="downloadTip">iPad Mode: Videos are stored locally, use "Download All" to save them</span> -->
    </div>
  </div>

<script>
const el = id => document.getElementById(id);
let stream, mediaRecorder, chunks = [];
let sentences = [];
let idx = 0;
let recording = false;
let recordingTimer = null; // Timer for auto-stop after 1 minute
let recordingStartTime = null; // Track recording start time
let timerInterval = null; // Timer display update interval
let storageMode = true; // Default to iPad mode (store locally)
let isRedo = false; // flag for redo mode
let db;

// Initialize IndexedDB
async function initDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('VideoRecorderDB', 2);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => {
      db = request.result;
      resolve(db);
    };
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      
      // Video storage table
      if (!db.objectStoreNames.contains('videos')) {
        const store = db.createObjectStore('videos', { keyPath: 'id', autoIncrement: true });
        store.createIndex('timestamp', 'timestamp', { unique: false });
        store.createIndex('sentence', 'sentence', { unique: false });
        store.createIndex('sentenceSet', 'sentenceSet', { unique: false });
        store.createIndex('sentenceIndex', 'sentenceIndex', { unique: false });
      }
      
      // Progress tracking table
      if (!db.objectStoreNames.contains('progress')) {
        const progressStore = db.createObjectStore('progress', { keyPath: 'sentenceSet' });
      }
    };
  });
}

// Store video to IndexedDB
async function storeVideo(blob, fileName, sentence, sentenceSet, sentenceIndex) {
  return new Promise(async (resolve, reject) => {
    try {
      // Convert Blob to ArrayBuffer for IndexedDB storage
      const arrayBuffer = await blob.arrayBuffer();
      
      const transaction = db.transaction(['videos'], 'readwrite');
      const store = transaction.objectStore('videos');
      
      const videoData = {
        fileName: fileName,
        arrayBuffer: arrayBuffer, // Store as ArrayBuffer instead of Blob
        mimeType: blob.type, // Store MIME type separately
        sentence: sentence,
        sentenceSet: sentenceSet || 'custom',
        sentenceIndex: sentenceIndex || idx,
        timestamp: new Date().toISOString(),
        size: blob.size
      };
      
      const request = store.add(videoData);
      request.onsuccess = () => {
        console.log(`Video stored successfully: ${fileName}`);
        resolve(request.result);
      };
      request.onerror = () => {
        console.error('IndexedDB store error:', request.error);
        reject(request.error);
      };
      
      transaction.onerror = () => {
        console.error('IndexedDB transaction error:', transaction.error);
        reject(transaction.error);
      };
    } catch (error) {
      console.error('Error converting blob to ArrayBuffer:', error);
      reject(error);
    }
  });
}

// Save progress
async function saveProgress(sentenceSet, currentIndex, isCompletion = false) {
  return new Promise(async (resolve, reject) => {
    try {
      // Get existing progress to check repetition count
      const existingProgress = await getProgress(sentenceSet);
      let repetitionCount = existingProgress ? (existingProgress.repetitionCount || 0) : 0;
      
      // If this is a completion, increment repetition count
      if (isCompletion) {
        repetitionCount++;
      }
      
      const transaction = db.transaction(['progress'], 'readwrite');
      const store = transaction.objectStore('progress');
      
      const progressData = {
        sentenceSet: sentenceSet,
        currentIndex: currentIndex,
        repetitionCount: repetitionCount,
        timestamp: new Date().toISOString()
      };
      
      const request = store.put(progressData);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    } catch (error) {
      reject(error);
    }
  });
}

// Get progress
async function getProgress(sentenceSet) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['progress'], 'readonly');
    const store = transaction.objectStore('progress');
    const request = store.get(sentenceSet);
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// Delete progress
async function deleteProgress(sentenceSet) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['progress'], 'readwrite');
    const store = transaction.objectStore('progress');
    const request = store.delete(sentenceSet);
    
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

// Get all stored videos
async function getAllStoredVideos() {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['videos'], 'readonly');
    const store = transaction.objectStore('videos');
    const request = store.getAll();
    
    request.onsuccess = () => {
      const videos = request.result;
      // Convert ArrayBuffer back to Blob for each video
      const videosWithBlobs = videos.map(video => ({
        ...video,
        blob: new Blob([video.arrayBuffer], { type: video.mimeType || 'video/mp4' })
      }));
      resolve(videosWithBlobs);
    };
    request.onerror = () => reject(request.error);
  });
}

// Delete stored video
async function deleteStoredVideo(id) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['videos'], 'readwrite');
    const store = transaction.objectStore('videos');
    const request = store.delete(id);
    
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

// Clear all stored videos
async function clearAllStoredVideos() {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['videos'], 'readwrite');
    const store = transaction.objectStore('videos');
    const request = store.clear();
    
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

// Sentence sets data
const sentenceSets = {
  '50_repeat6_sentences': null,
  '300_nonrepeating_sentences': null
};

let currentSentenceSet = '300_nonrepeating_sentences';
let isWarmupMode = false;
let warmupSentences = [];
let warmupIndex = 0;

// Load sentence set file
async function loadSentenceFile(filename) {
  try {
    const response = await fetch(`materials/${filename}`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const text = await response.text();
    return text.split('\n').map(s => s.trim()).filter(Boolean);
  } catch (error) {
    console.error(`Failed to load sentence file (${filename}):`, error);
    return null;
  }
}

// Load warmup sentences (first 5 from 50_repeat6_sentences.txt)
async function loadWarmupSentences() {
  try {
    const response = await fetch(`materials/../newset/50_repeat6_sentences.txt`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const text = await response.text();
    const allSentences = text.split('\n').map(s => s.trim()).filter(Boolean);
    return allSentences.slice(0, 5); // Get first 5 sentences
  } catch (error) {
    console.error('Failed to load warmup sentences:', error);
    return [];
  }
}

// Load sentence set
async function loadSentenceSet() {
  const selected = el('sentenceSet').value;
  currentSentenceSet = selected;
  
  let filename;
  if (selected === '50_repeat6_sentences') {
    filename = '../newset/50_repeat6_sentences.txt';
  } else if (selected === '300_nonrepeating_sentences') {
    filename = '../newset/300_nonrepeating_sentences.txt';
  }
  
  // Load sentences from cache or file
  if (!sentenceSets[selected]) {
    sentenceSets[selected] = await loadSentenceFile(filename);
  }
  
  if (sentenceSets[selected]) {
    sentences = sentenceSets[selected];
    
    // Restore progress
    try {
      const progress = await getProgress(selected);
      if (progress && progress.currentIndex < sentences.length) {
        idx = progress.currentIndex;
        console.log(`Progress restored: sentence ${idx + 1}`);
      } else {
        idx = 0;
      }
    } catch (error) {
      console.error('Failed to restore progress:', error);
      idx = 0;
    }
    
    await updateSentenceView();
  } else {
    sentences = [];
    idx = 0;
    await updateSentenceView();
  }
}

// Reset progress
async function resetProgress() {
  if (!confirm('Are you sure you want to reset the recording progress for the current sentence set?')) return;
  
  try {
    await deleteProgress(currentSentenceSet);
    idx = 0;
    await updateSentenceView();
    alert('Progress has been reset');
  } catch (error) {
    console.error('Failed to reset progress:', error);
    alert('Failed to reset progress: ' + error.message);
  }
}

// Clear all progress
async function clearAllProgress() {
  if (!confirm('Are you sure you want to clear all recording progress? This action cannot be undone!')) return;
  
  try {
    const transaction = db.transaction(['progress'], 'readwrite');
    const store = transaction.objectStore('progress');
    await new Promise((resolve, reject) => {
      const request = store.clear();
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
    
    // Reset current progress
    idx = 0;
    await updateSentenceView();
    alert('All progress has been cleared');
  } catch (error) {
    console.error('Failed to clear progress:', error);
    alert('Failed to clear progress: ' + error.message);
  }
}

// Initialize database
initDB().then(() => {
  console.log('IndexedDB initialized successfully');
  updateStorageInfo();
  // Try to restore sentence set selection on page load
  loadSentenceSet();
}).catch(err => {
  console.error('IndexedDB initialization failed:', err);
});

// Ordinal function to convert numbers to ordinal form (1st, 2nd, 3rd, etc.)
const ordinal = (n) => {
  const s = ["th", "st", "nd", "rd"];
  const v = n % 100;
  return n + (s[(v - 20) % 10] || s[v] || s[0]);
};

async function updateSentenceView(){
  const currentTextEl = el('currentText');
  const progressEl = el('idxInfo');
  
  // Clear all text nodes but keep the progress indicator
  currentTextEl.childNodes.forEach(node => {
    if (node.nodeType === Node.TEXT_NODE) {
      node.remove();
    }
  });
  
  let text = '';
  let progressText = '';
  
  if (isWarmupMode) {
    // Warmup mode
    text = warmupSentences.length ? warmupSentences[warmupIndex] : 'No warmup sentences available';
    progressText = warmupSentences.length ? `WARMUP ${warmupIndex + 1} / ${warmupSentences.length}` : '';
  } else {
    // Normal recording mode
    const total = sentences.length;
    text = total ? sentences[idx] : '';
    progressText = total ? `${idx+1} / ${total}` : '';
    
    // Always display repetition count, starting from 1st repeat
    try {
      const progress = await getProgress(currentSentenceSet);
      const repeatCount = progress ? (progress.repetitionCount || 0) + 1 : 1;
      progressText += `    ${ordinal(repeatCount)} repeat`;
    } catch (error) {
      console.error('Failed to get progress for repetition count:', error);
      progressText += `    1st repeat`;
    }
  }
  
  // Add the new text
  const textNode = document.createTextNode(text || 'No sentences available');
  currentTextEl.insertBefore(textNode, progressEl);
  
  progressEl.textContent = progressText;
  
  // Add default preparing state (blinking gray)
  currentTextEl.className = 'big sentence-preparing';
}

function updateRecordingTimer() {
  if (!recording || !recordingStartTime) return;
  
  const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
  const minutes = Math.floor(elapsed / 60);
  const seconds = elapsed % 60;
  const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
  
  const statusText = isWarmupMode ? `üî¥ WARMUP ${timeStr}` : `üî¥ REC ${timeStr}`;
  el('recordingStatus').textContent = statusText;
}

function playRecordingStartSound() {
  try {
    // Create audio context
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Create oscillator for the "beep" sound
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    // Connect oscillator to gain to destination
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    // Set frequency for a pleasant "beep" sound (around 800Hz)
    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
    
    // Set volume envelope for a quick "beep"
    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
    gainNode.gain.linearRampToValueAtTime(0.6, audioContext.currentTime + 0.01);
    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
    
    // Start and stop the sound
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.2);
  } catch (error) {
    // Silently fail if audio context is not available
    console.log('Audio not available:', error);
  }
}

function playRecordingStopSound() {
  try {
    // Create audio context
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Create oscillator for the "stop" sound (lower pitch)
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    // Connect oscillator to gain to destination
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    // Set frequency for a lower "stop" sound (around 500Hz)
    oscillator.frequency.setValueAtTime(500, audioContext.currentTime);
    
    // Set volume envelope for a slightly longer "stop" sound
    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
    gainNode.gain.linearRampToValueAtTime(0.6, audioContext.currentTime + 0.01);
    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
    
    // Start and stop the sound
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.3);
  } catch (error) {
    // Silently fail if audio context is not available
    console.log('Audio not available:', error);
  }
}

el('init').onclick = async () => {
  try {
    // Get user selected resolution
    const resolution = el('resolution').value;
    let videoConstraints = { facingMode: 'user' };
    
    // Set resolution based on selection
    if (resolution !== 'auto') {
      const resolutions = {
        '360p': { width: 640, height: 360 },
        '480p': { width: 854, height: 480 },
        '720p': { width: 1280, height: 720 },
        '1080p': { width: 1920, height: 1080 }
      };
      
      if (resolutions[resolution]) {
        videoConstraints = {
          ...videoConstraints,
          width: { ideal: resolutions[resolution].width },
          height: { ideal: resolutions[resolution].height }
        };
      }
    }
    
    // Front camera; change 'user' to 'environment' for rear camera
    stream = await navigator.mediaDevices.getUserMedia({
      video: videoConstraints,
      audio: true
    });
    
    el('preview').srcObject = stream;
    
    // Load warmup sentences and ask user if they want to skip warmup
    warmupSentences = await loadWarmupSentences();
    if (warmupSentences.length > 0) {
      // Ask user if they want to skip warmup
      const skipWarmup = confirm('üéØ WARMUP OPTION\n\nWould you like to do a 5-sentence warmup first?\n\n‚Ä¢ Click OK for "Warm up first and then start formal recording"\n‚Ä¢ Click Cancel for "Go to formal recording directly"');
      
      if (skipWarmup) {
        // Start warmup mode - don't load formal sentences yet
        isWarmupMode = true;
        warmupIndex = 0;
        await updateSentenceView();
        
        // Show warmup notification
        alert('üéØ WARMUP MODE\n\nYou are now in warmup mode with 5 practice sentences.\nThese recordings will NOT be saved.\n\nPress Space to practice, then we will start the formal recording session.');
      } else {
        // Skip warmup and go directly to formal recording
        isWarmupMode = false;
        warmupIndex = 0;
        await loadSentenceSet();
        await updateSentenceView();
        
        alert('üé¨ FORMAL RECORDING BEGINS\n\nCamera ready! Warmup skipped.\nAll recordings will be saved.\n\n');
      }
    } else {
      // Fallback to normal mode if warmup fails
      isWarmupMode = false;
      await loadSentenceSet();
      await updateSentenceView();
    }
    
    // Apply mirror effect if enabled
    updateVideoMirror();
    
    // Display actual resolution obtained
    const videoTrack = stream.getVideoTracks()[0];
    const settings = videoTrack.getSettings();
    const actualRes = `${settings.width}√ó${settings.height}`;
    el('resolutionInfo').textContent = `Actual Resolution: ${actualRes}`;
    
    // Show storage buttons since we're in iPad mode by default
    el('downloadAll').style.display = 'inline-block';
    el('clearAll').style.display = 'inline-block';
    
    // Hide the Initialize Camera button overlay and show preparing status
    el('initCameraOverlay').style.display = 'none';
    el('recordingStatus').style.display = 'block';
  } catch (e) {
    alert('Unable to access camera/microphone: ' + e);
  }
};

el('next').onclick = async () => { 
  if (sentences.length){ 
    idx = Math.min(idx+1, sentences.length-1); 
    isRedo = false; // Reset redo flag
    await updateSentenceView(); 
    // Save progress
    try {
      await saveProgress(currentSentenceSet, idx);
    } catch (error) {
      console.error('Failed to save progress:', error);
    }
  } 
};

el('prev').onclick = async () => { 
  if (sentences.length){ 
    idx = Math.max(idx-1, 0); 
    isRedo = false; // Reset redo flag
    await updateSentenceView(); 
    // Save progress
    try {
      await saveProgress(currentSentenceSet, idx);
    } catch (error) {
      console.error('Failed to save progress:', error);
    }
  } 
};

// Skip current sentence
el('skip').onclick = async () => {
  if (sentences.length && idx < sentences.length - 1) {
    idx++;
    isRedo = false; // Reset redo flag
    await updateSentenceView();
    // Save progress
    try {
      await saveProgress(currentSentenceSet, idx);
      console.log(`Skipped to sentence ${idx + 1}`);
    } catch (error) {
      console.error('Failed to save progress:', error);
    }
  } else if (idx >= sentences.length - 1) {
    alert('This is the last sentence!');
  }
};

// Redo last sentence (go back to previous sentence)
el('redo').onclick = async () => {
  if (isWarmupMode) {
    // Warmup mode: go back to previous warmup sentence
    if (warmupSentences.length && warmupIndex > 0) {
      warmupIndex--; // Go back to previous warmup sentence
      console.log(`Redo warmup sentence ${warmupIndex + 1}: ${warmupSentences[warmupIndex]}`);
      await updateSentenceView();
    } else {
      console.log('Cannot redo: already at first warmup sentence');
    }
  } else {
    // Normal mode: go back to previous formal sentence
    if (sentences.length && idx > 0) {
      idx--; // Go back to previous sentence
      isRedo = true; // Set redo flag for video naming
      console.log(`Redo last sentence ${idx + 1}: ${sentences[idx]}`);
      await updateSentenceView();
      // Save progress
      try {
        await saveProgress(currentSentenceSet, idx);
      } catch (error) {
        console.error('Failed to save progress:', error);
      }
    } else {
      console.log('Cannot redo: already at first sentence or no sentences available');
    }
  }
};

// Update video mirror effect
function updateVideoMirror() {
  const videoElement = el('preview');
  const mirrorCheckbox = el('mirrorVideo');
  
  if (mirrorCheckbox.checked) {
    videoElement.classList.add('video-mirrored');
  } else {
    videoElement.classList.remove('video-mirrored');
  }
}

// Listen for mirror toggle changes
el('mirrorVideo').onchange = () => {
  updateVideoMirror();
};

// Listen for resolution changes
el('resolution').onchange = () => {
  if (stream) {
    el('resolutionInfo').textContent = 'Resolution changed, please reinitialize camera';
    
    // Show the Initialize Camera button overlay
    el('initCameraOverlay').style.display = 'block';
    
    // Hide the recording status
    el('recordingStatus').style.display = 'none';
    
    // Stop any ongoing recording
    if (recording && mediaRecorder) {
      mediaRecorder.stop();
      recording = false;
      
      // Clear timers
      if (recordingTimer) {
        clearTimeout(recordingTimer);
        recordingTimer = null;
      }
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      recordingStartTime = null;
      
      // Reset button states
      el('start').classList.remove('button-pressed');
      el('stop').classList.remove('button-pressed');
    }
  }
};


// Update storage info
async function updateStorageInfo() {
  if (!db) {
    console.log('Database not initialized yet');
    return;
  }
  
  try {
    const videos = await getAllStoredVideos();
    const count = videos.length;
    const totalSize = videos.reduce((sum, video) => sum + video.size, 0);
    const sizeInMB = (totalSize / (1024 * 1024)).toFixed(1);
    
    el('storageInfo').textContent = count > 0 ? `Cached ${count} videos, ~${sizeInMB} MB` : '';
    
    console.log(`Storage info updated: ${count} videos, ${sizeInMB} MB`);
  } catch (error) {
    console.error('Failed to update storage info:', error);
    // Update UI even if error occurs to avoid freezing
    el('storageInfo').textContent = '';
  }
}


// Download all stored videos
el('downloadAll').onclick = async () => {
  try {
    const videos = await getAllStoredVideos();
    if (videos.length === 0) {
      alert('No stored videos found');
      return;
    }
    
    if (!confirm(`Are you sure you want to download all ${videos.length} videos as a ZIP file? Videos will be automatically cleared from cache after download.\n\nAfter SAVE ALL: If you want to continue recording, remember to refresh the page to avoid frozen video.`)) return;
    
    // Show progress indicator
    el('downloadAll').textContent = 'Creating ZIP...';
    el('downloadAll').disabled = true;
    
    // Create ZIP file
    const zip = new JSZip();
    
    // Add all videos to ZIP
    for (let i = 0; i < videos.length; i++) {
      const video = videos[i];
      console.log(`Adding to ZIP: ${video.fileName}`);
      
      // Convert blob to array buffer for ZIP
      const arrayBuffer = await video.blob.arrayBuffer();
      zip.file(video.fileName, arrayBuffer);
      
      // Update progress
      el('downloadAll').textContent = `Adding ${i + 1}/${videos.length}...`;
    }
    
    // Generate ZIP file
    el('downloadAll').textContent = 'Generating ZIP...';
    const zipBlob = await zip.generateAsync({ type: 'blob' });
    
    // Create download link for ZIP
    const currentDate = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const zipFileName = `video-recordings-${currentDate}.zip`;
    
    const a = document.createElement('a');
    a.download = zipFileName;
    a.href = URL.createObjectURL(zipBlob);
    a.click();
    URL.revokeObjectURL(a.href);
    
    console.log(`Downloaded ZIP file: ${zipFileName}`);
    
    // Delete all videos from storage
    for (const video of videos) {
      try {
        await deleteStoredVideo(video.id);
        console.log(`Deleted stored video: ${video.fileName}`);
      } catch (error) {
        console.error(`Failed to delete video: ${video.fileName}`, error);
      }
    }
    
    // Update storage info and restart video stream
    setTimeout(async () => {
      try {
        updateStorageInfo();
        
        // Restart video stream to refresh camera feed
        if (stream) {
          // Stop current stream
          stream.getTracks().forEach(track => track.stop());
          
          // Restart camera with current resolution
          const resolution = el('resolution').value;
          let videoConstraints = { facingMode: 'user' };
          
          if (resolution === '4k') videoConstraints = { ...videoConstraints, width: 3840, height: 2160 };
          else if (resolution === '1080p') videoConstraints = { ...videoConstraints, width: 1920, height: 1080 };
          else if (resolution === '720p') videoConstraints = { ...videoConstraints, width: 1280, height: 720 };
          else if (resolution === '480p') videoConstraints = { ...videoConstraints, width: 640, height: 480 };
          
          stream = await navigator.mediaDevices.getUserMedia({ 
            video: videoConstraints, 
            audio: true 
          });
          el('preview').srcObject = stream;
          
          // Apply mirror effect after restarting stream
          updateVideoMirror();
          
          console.log('Video stream restarted after ZIP download');
        }
        
        // Reset button
        el('downloadAll').textContent = 'üíæ SAVE ALL';
        el('downloadAll').disabled = false;
        
      } catch (error) {
        console.error('Error restarting video stream:', error);
        el('downloadAll').textContent = 'üíæ SAVE ALL';
        el('downloadAll').disabled = false;
      }
    }, 500);
    
  } catch (error) {
    alert('ZIP download failed: ' + error.message);
    el('downloadAll').textContent = 'üíæ SAVE ALL';
    el('downloadAll').disabled = false;
  }
};

// Clear all stored videos
el('clearAll').onclick = async () => {
  try {
    const videos = await getAllStoredVideos();
    if (videos.length === 0) {
      alert('No stored videos found');
      return;
    }
    
    if (!confirm(`Are you sure you want to clear all ${videos.length} stored videos? This action cannot be undone!`)) return;
    
    await clearAllStoredVideos();
    
    // Call updateStorageInfo again to ensure correct state
    setTimeout(() => {
      updateStorageInfo();
    }, 100);
    
    alert('All stored videos have been cleared');
  } catch (error) {
    console.error('Clear storage error:', error);
    alert('Failed to clear storage: ' + error.message);
  }
};

el('start').onclick = () => {
  if (!stream) return alert('Please initialize camera first!');
  if (recording) return;
  chunks = [];
  
  // Use MP4 format by default
  const mp4Options = [
    'video/mp4;codecs=h264,aac',
    'video/mp4;codecs=avc1.42E01E,mp4a.40.2',
    'video/mp4'
  ];
  const mimeType = mp4Options.find(type => MediaRecorder.isTypeSupported(type)) || 'video/webm;codecs=vp9,opus';
  
  mediaRecorder = new MediaRecorder(stream, { mimeType });
  mediaRecorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
  mediaRecorder.onstop = isWarmupMode ? () => {} : saveBlob; // Don't save in warmup mode
  
  // Play recording start sound
  playRecordingStartSound();
  
  mediaRecorder.start();
  recording = true;
  recordingStartTime = Date.now();
  
  // Set 1-minute auto-stop timer
  recordingTimer = setTimeout(() => {
    if (recording && mediaRecorder) {
      console.log('Auto-stopping recording after 1 minute');
      el('stop').click(); // Trigger stop button to handle all cleanup
    }
  }, 60000); // 60 seconds
  
  // Start timer display updates
  timerInterval = setInterval(updateRecordingTimer, 1000);
  
  // Update recording status and sentence appearance
  const statusText = isWarmupMode ? 'üî¥ WARMUP 0:00' : 'üî¥ REC 0:00';
  el('recordingStatus').textContent = statusText;
  el('recordingStatus').style.color = '#f44336';
  el('currentText').className = 'big sentence-recording';
  
  // Update button states - only START is pressed during recording
  el('start').classList.add('button-pressed');
  el('stop').classList.remove('button-pressed');
};

el('stop').onclick = () => {
  if (mediaRecorder && recording) {
    // Update button states - only STOP is pressed when stopping
    el('start').classList.remove('button-pressed');
    el('stop').classList.add('button-pressed');
    
    // Play recording stop sound
    playRecordingStopSound();
    
    mediaRecorder.stop();
    recording = false;
    
    // Clear the recording timer and timer display
    if (recordingTimer) {
      clearTimeout(recordingTimer);
      recordingTimer = null;
    }
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
    recordingStartTime = null;
    
    // Reset to preparing status
    el('recordingStatus').textContent = 'Preparing';
    el('recordingStatus').style.color = '#888';
    el('currentText').className = 'big sentence-preparing';
    
    // Handle warmup mode navigation
    if (isWarmupMode) {
      if (warmupIndex < warmupSentences.length - 1) {
        // Move to next warmup sentence
        warmupIndex++;
        updateSentenceView();
      } else {
        // Warmup completed, start formal recording
        isWarmupMode = false;
        warmupIndex = 0;
        
        // Load the selected sentence set and restore progress
        loadSentenceSet().then(() => {
          alert('üé¨ FORMAL RECORDING BEGINS\n\nWarmup completed! Now starting the formal recording session.\nAll recordings from now on will be saved.\n\nGood luck!');
        });
      }
    }
    
    // Keep Stop button pressed until Start is pressed again
  }
};

// Add keyboard shortcut support
document.addEventListener('keydown', (event) => {
  // Only trigger when not focused on input elements
  if (!['INPUT', 'TEXTAREA', 'SELECT'].includes(event.target.tagName)) {
    
    // Spacebar: Start/Stop recording
    if (event.code === 'Space') {
      event.preventDefault(); // Prevent page scrolling
      
      if (!recording) {
        // Start recording
        el('start').click();
      } else {
        // Stop recording
        el('stop').click();
      }
    }
    
    // Left Arrow: Redo last sentence
    else if (event.code === 'ArrowLeft') {
      event.preventDefault(); // Prevent default behavior
      
      if (!recording) { // Only allow redo when not recording
        el('redo').click();
      }
    }
  }
});

function sanitize(s){
  return s.replace(/[\\/:*?"<>|]/g,'').replace(/\s+/g,' ').trim();
}
function ts(){
  const d = new Date();
  const pad = n => String(n).padStart(2,'0');
  return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
}
async function saveBlob(){
  // Determine file extension based on actual mimeType used
  const isMP4 = mediaRecorder.mimeType.includes('mp4');
  const fileExt = isMP4 ? 'mp4' : 'webm';
  const blobType = isMP4 ? 'video/mp4' : 'video/webm';
  
  const blob = new Blob(chunks, { type: blobType });
  const sentence = sentences[idx] ? sanitize(sentences[idx]) : 'unknown_sentence';
  const timestamp = ts();
  const redoSuffix = isRedo ? '_redo' : '';
  
  // Get progress info for filename
  let progressInfo = '';
  try {
    const progress = await getProgress(currentSentenceSet);
    const total = sentences.length;
    const currentPos = idx + 1;
    
    // Always include repeat count in filename, starting from repeat1
    const repeatCount = progress ? (progress.repetitionCount || 0) + 1 : 1;
    progressInfo = `_${currentPos}-${total}_repeat${repeatCount}`;
  } catch (error) {
    console.error('Failed to get progress for filename:', error);
    progressInfo = `_${idx + 1}-${sentences.length}`;
  }
  
  const fileName = `${sentence}${progressInfo}_${timestamp}${redoSuffix}.mp4`;
  
  if (storageMode) {
    // iPad mode: Store to IndexedDB
          try {
        await storeVideo(blob, fileName, sentences[idx] || 'unknown sentence', currentSentenceSet, idx);
        updateStorageInfo();
        console.log(`Video stored locally: ${fileName}`);
      } catch (error) {
      console.error('Failed to store video:', error);
      alert('Failed to store video: ' + error.message);
      // Fallback to direct download on failure
      directDownload(blob, fileName);
    }
  } else {
    // Normal mode: Direct download
    directDownload(blob, fileName);
  }
  
  // Reset redo flag after recording completion
  isRedo = false;
  
  // Auto jump to next sentence after recording completion (if not the last sentence)
  if (idx < sentences.length - 1) {
    idx++;
    await updateSentenceView();
    
    // Save progress
    try {
      await saveProgress(currentSentenceSet, idx);
      console.log(`Auto moved to next sentence: sentence ${idx + 1}`);
    } catch (error) {
      console.error('Failed to save progress:', error);
    }
  } else {
    // All sentences completed, reset to first sentence for repetition
    idx = 0;
    
    // Save progress and increment repetition counter FIRST
    try {
      await saveProgress(currentSentenceSet, idx, true); // true indicates completion
      console.log(`Completed recording all ${sentences.length} sentences, starting next repetition`);
    } catch (error) {
      console.error('Failed to save progress:', error);
    }
    
    // Then update the sentence view to show the new repetition count
    await updateSentenceView();
  }
  
  // Display format information
  console.log(`Recording completed, format: ${fileExt.toUpperCase()}, MIME type: ${mediaRecorder.mimeType}`);
}

function directDownload(blob, fileName) {
  const a = document.createElement('a');
  a.download = fileName;
  a.href = URL.createObjectURL(blob);
  a.click();
  URL.revokeObjectURL(a.href);
}
</script>
</body>
</html>