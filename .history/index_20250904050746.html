<!doctype html>
<html>
<meta charset="utf-8" />
<title>句子录制小工具</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;max-width:800px;margin:24px auto;padding:0 16px;line-height:1.5}
  .card{border:1px solid #ddd;border-radius:12px;padding:16px;margin:16px 0}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  video{width:100%;max-height:50vh;background:#000;border-radius:12px}
  button{padding:10px 14px;border-radius:10px;border:1px solid #ccc;background:#fff}
  button:active{opacity:.8}
  input,textarea{width:100%;padding:10px;border-radius:10px;border:1px solid #ccc}
  .big{font-size:1.4rem;font-weight:600;margin:8px 0}
  .muted{color:#666}
</style>
<body>
  <h1>句子录制小工具</h1>

  <div class="card">
    <div class="row">
      <label>输入句子（每行一条）</label>
      <textarea id="sentences" rows="6" placeholder="第一句
第二句
第三句"></textarea>
    </div>
    <div class="row">
      <label>文件名前缀（可选）</label>
      <input id="prefix" placeholder="如: S01"/>
    </div>
    <div class="row">
      <label>输出格式</label>
      <select id="format">
        <option value="mp4">MP4 (推荐)</option>
        <option value="webm">WebM</option>
      </select>
    </div>
    <div class="row">
      <label>录制分辨率</label>
      <select id="resolution">
        <option value="720p">720p (1280×720) - 推荐</option>
        <option value="1080p">1080p (1920×1080) - 高清</option>
        <option value="480p">480p (854×480) - 标清</option>
        <option value="360p">360p (640×360) - 低清</option>
        <option value="auto">自动 - 使用摄像头默认</option>
      </select>
    </div>
    <div class="row">
      <button id="init">初始化摄像头</button>
      <button id="prev">上一句</button>
      <button id="next">下一句</button>
      <span class="muted" id="idxInfo"></span>
    </div>
    <div class="big" id="currentText">（待初始化）</div>
  </div>

  <div class="card">
    <video id="preview" playsinline autoplay muted></video>
    <div class="row" style="margin-top:8px">
      <button id="start">开始录制</button>
      <button id="stop">停止并保存</button>
    </div>
    <div class="row">
      <label>保存模式</label>
      <select id="saveMode" onchange="changeSaveMode()">
        <option value="download">直接下载</option>
        <option value="local">本地存储（iPad推荐）</option>
        <option value="server">上传到服务器</option>
      </select>
      <input id="serverUrl" placeholder="服务器地址 (如: https://your-server.com/upload)" style="display:none; margin-left:8px; width:300px;">
      <button id="testServer" style="display:none; margin-left:8px;" onclick="testServerConnection()">测试连接</button>
    </div>
    <div class="row">
      <button id="viewStored" style="display:none">查看已存储视频 (0)</button>
      <button id="downloadAll" style="display:none">下载所有</button>
      <button id="clearAll" style="display:none">清空存储</button>
      <span class="muted" id="resolutionInfo"></span>
      <span class="muted" id="storageInfo"></span>
    </div>
    <div class="row">
      <span class="muted" id="downloadTip">提示：先在"设置 → Safari → 下载"选好固定保存文件夹</span>
    </div>
  </div>

<script>
const el = id => document.getElementById(id);
let stream, mediaRecorder, chunks = [];
let sentences = [];
let idx = 0;
let recording = false;
let saveMode = 'download'; // 'download', 'local', 'server'
let db;

// 初始化IndexedDB
async function initDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('VideoRecorderDB', 1);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => {
      db = request.result;
      resolve(db);
    };
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains('videos')) {
        const store = db.createObjectStore('videos', { keyPath: 'id', autoIncrement: true });
        store.createIndex('timestamp', 'timestamp', { unique: false });
        store.createIndex('sentence', 'sentence', { unique: false });
      }
    };
  });
}

// 存储视频到IndexedDB
async function storeVideo(blob, fileName, sentence) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['videos'], 'readwrite');
    const store = transaction.objectStore('videos');
    
    const videoData = {
      fileName: fileName,
      blob: blob,
      sentence: sentence,
      timestamp: new Date().toISOString(),
      size: blob.size
    };
    
    const request = store.add(videoData);
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// 获取所有存储的视频
async function getAllStoredVideos() {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['videos'], 'readonly');
    const store = transaction.objectStore('videos');
    const request = store.getAll();
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// 删除存储的视频
async function deleteStoredVideo(id) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['videos'], 'readwrite');
    const store = transaction.objectStore('videos');
    const request = store.delete(id);
    
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

// 清空所有存储的视频
async function clearAllStoredVideos() {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['videos'], 'readwrite');
    const store = transaction.objectStore('videos');
    const request = store.clear();
    
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

// 初始化数据库
initDB().then(() => {
  console.log('IndexedDB 初始化成功');
  updateStorageInfo();
}).catch(err => {
  console.error('IndexedDB 初始化失败:', err);
});

function updateSentenceView(){
  const total = sentences.length;
  const text = total ? sentences[idx] : '';
  el('currentText').textContent = text || '（没有句子）';
  el('idxInfo').textContent = total ? `第 ${idx+1}/${total} 句` : '';
}

el('init').onclick = async () => {
  try {
    // 获取用户选择的分辨率
    const resolution = el('resolution').value;
    let videoConstraints = { facingMode: 'user' };
    
    // 根据选择设置分辨率
    if (resolution !== 'auto') {
      const resolutions = {
        '360p': { width: 640, height: 360 },
        '480p': { width: 854, height: 480 },
        '720p': { width: 1280, height: 720 },
        '1080p': { width: 1920, height: 1080 }
      };
      
      if (resolutions[resolution]) {
        videoConstraints = {
          ...videoConstraints,
          width: { ideal: resolutions[resolution].width },
          height: { ideal: resolutions[resolution].height }
        };
      }
    }
    
    // 前置摄像头；如需后置，把 'user' 改为 'environment'
    stream = await navigator.mediaDevices.getUserMedia({
      video: videoConstraints,
      audio: true
    });
    
    el('preview').srcObject = stream;
    sentences = el('sentences').value
      .split('\n').map(s=>s.trim()).filter(Boolean);
    idx = 0;
    updateSentenceView();
    
    // 显示实际获取到的分辨率
    const videoTrack = stream.getVideoTracks()[0];
    const settings = videoTrack.getSettings();
    const actualRes = `${settings.width}×${settings.height}`;
    el('resolutionInfo').textContent = `实际分辨率: ${actualRes}`;
    
    alert('摄像头就绪！可以开始录制了。');
  } catch (e) {
    alert('无法获取摄像头/麦克风权限：' + e);
  }
};

el('next').onclick = () => { if (sentences.length){ idx = Math.min(idx+1, sentences.length-1); updateSentenceView(); }};
el('prev').onclick = () => { if (sentences.length){ idx = Math.max(idx-1, 0); updateSentenceView(); }};

// 监听分辨率变化
el('resolution').onchange = () => {
  if (stream) {
    el('resolutionInfo').textContent = '分辨率已更改，请重新初始化摄像头';
  }
};

// 切换保存模式
function changeSaveMode() {
  saveMode = el('saveMode').value;
  
  // 隐藏所有模式相关的元素
  el('viewStored').style.display = 'none';
  el('downloadAll').style.display = 'none';
  el('clearAll').style.display = 'none';
  el('serverUrl').style.display = 'none';
  
  // 根据模式显示相应元素和提示
  switch(saveMode) {
    case 'download':
      el('downloadTip').textContent = '提示：先在"设置 → Safari → 下载"选好固定保存文件夹';
      break;
      
    case 'local':
      el('viewStored').style.display = 'inline-block';
      el('downloadAll').style.display = 'inline-block';
      el('clearAll').style.display = 'inline-block';
      el('downloadTip').textContent = '本地存储模式：视频将存储到浏览器本地，可稍后批量下载';
      updateStorageInfo();
      break;
      
    case 'server':
      el('serverUrl').style.display = 'inline-block';
      el('testServer').style.display = 'inline-block';
      el('downloadTip').textContent = '服务器模式：视频将直接上传到指定的服务器地址（需要支持CORS的服务器）';
      break;
  }
}

// 更新存储信息
async function updateStorageInfo() {
  if (!db) return;
  
  try {
    const videos = await getAllStoredVideos();
    const count = videos.length;
    const totalSize = videos.reduce((sum, video) => sum + video.size, 0);
    const sizeInMB = (totalSize / (1024 * 1024)).toFixed(1);
    
    el('viewStored').textContent = `查看已存储视频 (${count})`;
    el('storageInfo').textContent = count > 0 ? `已存储 ${count} 个视频，约 ${sizeInMB} MB` : '';
  } catch (error) {
    console.error('更新存储信息失败:', error);
  }
}

// 查看存储的视频
el('viewStored').onclick = async () => {
  try {
    const videos = await getAllStoredVideos();
    if (videos.length === 0) {
      alert('暂无存储的视频');
      return;
    }
    
    let list = '存储的视频列表：\n\n';
    videos.forEach((video, index) => {
      const date = new Date(video.timestamp).toLocaleString();
      const sizeMB = (video.size / (1024 * 1024)).toFixed(1);
      list += `${index + 1}. ${video.fileName}\n   句子: ${video.sentence}\n   时间: ${date}\n   大小: ${sizeMB} MB\n\n`;
    });
    
    alert(list);
  } catch (error) {
    alert('获取存储视频失败: ' + error.message);
  }
};

// 下载所有存储的视频
el('downloadAll').onclick = async () => {
  try {
    const videos = await getAllStoredVideos();
    if (videos.length === 0) {
      alert('暂无存储的视频');
      return;
    }
    
    if (!confirm(`确定要下载所有 ${videos.length} 个视频吗？`)) return;
    
    // 逐个下载，间隔300ms
    for (let i = 0; i < videos.length; i++) {
      setTimeout(() => {
        const video = videos[i];
        const a = document.createElement('a');
        a.download = video.fileName;
        a.href = URL.createObjectURL(video.blob);
        a.click();
        URL.revokeObjectURL(a.href);
      }, i * 300);
    }
    
    el('storageInfo').textContent = `正在下载 ${videos.length} 个视频...`;
  } catch (error) {
    alert('下载失败: ' + error.message);
  }
};

// 清空所有存储的视频
el('clearAll').onclick = async () => {
  try {
    const videos = await getAllStoredVideos();
    if (videos.length === 0) {
      alert('暂无存储的视频');
      return;
    }
    
    if (!confirm(`确定要清空所有 ${videos.length} 个存储的视频吗？此操作不可恢复！`)) return;
    
    await clearAllStoredVideos();
    updateStorageInfo();
    alert('已清空所有存储的视频');
  } catch (error) {
    alert('清空失败: ' + error.message);
  }
};

// 上传视频到服务器
async function uploadToServer(blob, fileName, sentence) {
  const serverUrl = el('serverUrl').value.trim();
  
  if (!serverUrl) {
    throw new Error('请输入服务器地址');
  }
  
  // 创建FormData
  const formData = new FormData();
  formData.append('video', blob, fileName);
  formData.append('sentence', sentence || '');
  formData.append('timestamp', new Date().toISOString());
  formData.append('index', idx + 1);
  
  // 显示上传进度
  el('storageInfo').textContent = '正在上传...';
  
  try {
    const response = await fetch(serverUrl, {
      method: 'POST',
      body: formData,
      // 添加一些常用的请求头
      headers: {
        // 不设置Content-Type，让浏览器自动设置multipart/form-data
      }
    });
    
    if (!response.ok) {
      throw new Error(`服务器响应错误: ${response.status} ${response.statusText}`);
    }
    
    const result = await response.text();
    el('storageInfo').textContent = `上传成功: ${fileName}`;
    console.log('上传成功:', result);
    
    return result;
  } catch (error) {
    el('storageInfo').textContent = `上传失败: ${error.message}`;
    throw error;
  }
}

el('start').onclick = () => {
  if (!stream) return alert('请先点"初始化摄像头"');
  if (recording) return;
  chunks = [];
  
  // 根据用户选择的格式确定mimeType
  const selectedFormat = el('format').value;
  let mimeType;
  
  if (selectedFormat === 'mp4') {
    // 尝试不同的MP4编码组合
    const mp4Options = [
      'video/mp4;codecs=h264,aac',
      'video/mp4;codecs=avc1.42E01E,mp4a.40.2',
      'video/mp4'
    ];
    mimeType = mp4Options.find(type => MediaRecorder.isTypeSupported(type)) || 'video/webm;codecs=vp9,opus';
  } else {
    mimeType = 'video/webm;codecs=vp9,opus';
  }
  
  mediaRecorder = new MediaRecorder(stream, { mimeType });
  mediaRecorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
  mediaRecorder.onstop = saveBlob;
  mediaRecorder.start();
  recording = true;
};

el('stop').onclick = () => {
  if (mediaRecorder && recording) {
    mediaRecorder.stop();
    recording = false;
  }
};

function sanitize(s){
  return s.replace(/[\\/:*?"<>|]/g,'').replace(/\s+/g,' ').trim();
}
function ts(){
  const d = new Date();
  const pad = n => String(n).padStart(2,'0');
  return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
}
async function saveBlob(){
  // 根据实际使用的mimeType确定文件扩展名
  const isMP4 = mediaRecorder.mimeType.includes('mp4');
  const fileExt = isMP4 ? 'mp4' : 'webm';
  const blobType = isMP4 ? 'video/mp4' : 'video/webm';
  
  const blob = new Blob(chunks, { type: blobType });
  const prefix = sanitize(el('prefix').value || '');
  const short = sentences[idx] ? sanitize(sentences[idx]).slice(0,12) : 'clip';
  const nameCore = [prefix, `S${String(idx+1).padStart(3,'0')}`, ts(), short].filter(Boolean).join('_');
  const fileName = `${nameCore}.${fileExt}`;
  const sentence = sentences[idx] || '未知句子';
  
  try {
    switch(saveMode) {
      case 'download':
        // 直接下载模式
        directDownload(blob, fileName);
        break;
        
      case 'local':
        // 本地存储模式
        await storeVideo(blob, fileName, sentence);
        updateStorageInfo();
        el('storageInfo').textContent = `视频已存储: ${fileName}`;
        console.log(`视频已存储到本地: ${fileName}`);
        break;
        
      case 'server':
        // 服务器上传模式
        await uploadToServer(blob, fileName, sentence);
        break;
        
      default:
        directDownload(blob, fileName);
    }
  } catch (error) {
    console.error(`保存视频失败 (${saveMode}模式):`, error);
    alert(`保存视频失败: ${error.message}`);
    
    // 失败时回退到直接下载
    if (saveMode !== 'download') {
      console.log('回退到直接下载模式');
      directDownload(blob, fileName);
    }
  }
  
  // 显示格式信息
  console.log(`录制完成，格式: ${fileExt.toUpperCase()}, MIME类型: ${mediaRecorder.mimeType}`);
}

function directDownload(blob, fileName) {
  const a = document.createElement('a');
  a.download = fileName;
  a.href = URL.createObjectURL(blob);
  a.click();
  URL.revokeObjectURL(a.href);
}
</script>
</body>
</html>