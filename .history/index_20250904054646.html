<!doctype html>
<html>
<meta charset="utf-8" />
<title>Video Recording Tool</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;max-width:800px;margin:24px auto;padding:0 16px;line-height:1.5}
  .card{border:1px solid #ddd;border-radius:12px;padding:16px;margin:16px 0}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  video{width:100%;max-height:50vh;background:#000;border-radius:12px}
  button{padding:10px 14px;border-radius:10px;border:1px solid #ccc;background:#fff}
  button:active{opacity:.8}
  input,textarea{width:100%;padding:10px;border-radius:10px;border:1px solid #ccc}
  .big{font-size:1.4rem;font-weight:600;margin:8px 0}
  .muted{color:#666}
</style>
<body>
  <h1>Video Recording Tool</h1>

  <div class="card">
    <div class="row">
      <label>Select Sentence Set</label>
      <select id="sentenceSet" onchange="loadSentenceSet()">
        <option value="50_sentences">50 Sentences</option>
        <option value="150_sentences">150 Sentences</option>
      </select>
      <button id="resetProgress" onclick="resetProgress()" style="margin-left: 8px;">Reset Progress</button>
      <button id="clearProgress" onclick="clearAllProgress()" style="margin-left: 8px;">Clear All Progress</button>
    </div>
    <div class="row">
      <label>Recording Resolution</label>
      <select id="resolution">
        <option value="720p">720p (1280√ó720) - Recommended</option>
        <option value="1080p">1080p (1920√ó1080) - High Quality</option>
        <option value="480p">480p (854√ó480) - Standard</option>
        <option value="360p">360p (640√ó360) - Low Quality</option>
        <option value="auto">Auto - Camera Default</option>
      </select>
    </div>
    <div class="row">
      <button id="init">Initialize Camera</button>
      <button id="prev">Previous</button>
      <button id="next">Next</button>
      <button id="skip">Skip</button>
      <button id="redo">Redo This</button>
      <span class="muted" id="idxInfo"></span>
    </div>
    <div class="big" id="currentText" style="font-size: 2rem; font-weight: bold; text-align: center; padding: 20px; border: 2px solid #ddd; border-radius: 12px; margin: 16px 0; min-height: 80px; display: flex; align-items: center; justify-content: center;">Waiting for initialization...</div>
  </div>

  <div class="card">
    <video id="preview" playsinline autoplay muted></video>
    <div class="row" style="margin-top:8px; justify-content: center;">
      <button id="start" style="font-size: 1.5rem; padding: 15px 30px; background: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; margin: 0 10px;">‚ñ∂ START RECORDING</button>
      <button id="stop" style="font-size: 1.5rem; padding: 15px 30px; background: #f44336; color: white; border: none; border-radius: 8px; cursor: pointer; margin: 0 10px;">‚èπ STOP & SAVE</button>
    </div>
    <div class="row" style="justify-content: center; margin-top: 10px;">
      <div id="recordingStatus" style="font-size: 1.2rem; font-weight: bold; color: #f44336; display: none;">üî¥ RECORDING IN PROGRESS</div>
    </div>
    <div class="row" style="margin-top:8px">
      <button id="downloadMode" onclick="toggleDownloadMode()">iPad Mode: Store Locally</button>
    </div>
    <div class="row">
      <button id="viewStored" style="display:none">View Stored Videos (0)</button>
      <button id="downloadAll" style="display:none">Download All</button>
      <button id="clearAll" style="display:none">Clear Storage</button>
      <span class="muted" id="resolutionInfo"></span>
      <span class="muted" id="storageInfo"></span>
    </div>
    <div class="row">
      <span class="muted" id="downloadTip">Tip: Set a fixed download folder in Settings ‚Üí Safari ‚Üí Downloads</span>
    </div>
  </div>

<script>
const el = id => document.getElementById(id);
let stream, mediaRecorder, chunks = [];
let sentences = [];
let idx = 0;
let recording = false;
let storageMode = false; // false=Áõ¥Êé•‰∏ãËΩΩ, true=Â≠òÂÇ®Âà∞Êú¨Âú∞
let isRedo = false; // Ê†áËÆ∞ÊòØÂê¶‰∏∫ÈáçÂΩïÊ®°Âºè
let db;

// ÂàùÂßãÂåñIndexedDB
async function initDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('VideoRecorderDB', 2);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => {
      db = request.result;
      resolve(db);
    };
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      
      // ËßÜÈ¢ëÂ≠òÂÇ®Ë°®
      if (!db.objectStoreNames.contains('videos')) {
        const store = db.createObjectStore('videos', { keyPath: 'id', autoIncrement: true });
        store.createIndex('timestamp', 'timestamp', { unique: false });
        store.createIndex('sentence', 'sentence', { unique: false });
        store.createIndex('sentenceSet', 'sentenceSet', { unique: false });
        store.createIndex('sentenceIndex', 'sentenceIndex', { unique: false });
      }
      
      // ËøõÂ∫¶ËÆ∞ÂΩïË°®
      if (!db.objectStoreNames.contains('progress')) {
        const progressStore = db.createObjectStore('progress', { keyPath: 'sentenceSet' });
      }
    };
  });
}

// Â≠òÂÇ®ËßÜÈ¢ëÂà∞IndexedDB
async function storeVideo(blob, fileName, sentence, sentenceSet, sentenceIndex) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['videos'], 'readwrite');
    const store = transaction.objectStore('videos');
    
    const videoData = {
      fileName: fileName,
      blob: blob,
      sentence: sentence,
      sentenceSet: sentenceSet || 'custom',
      sentenceIndex: sentenceIndex || idx,
      timestamp: new Date().toISOString(),
      size: blob.size
    };
    
    const request = store.add(videoData);
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// ‰øùÂ≠òËøõÂ∫¶
async function saveProgress(sentenceSet, currentIndex) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['progress'], 'readwrite');
    const store = transaction.objectStore('progress');
    
    const progressData = {
      sentenceSet: sentenceSet,
      currentIndex: currentIndex,
      timestamp: new Date().toISOString()
    };
    
    const request = store.put(progressData);
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

// Ëé∑ÂèñËøõÂ∫¶
async function getProgress(sentenceSet) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['progress'], 'readonly');
    const store = transaction.objectStore('progress');
    const request = store.get(sentenceSet);
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// ÈáçÁΩÆËøõÂ∫¶
async function deleteProgress(sentenceSet) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['progress'], 'readwrite');
    const store = transaction.objectStore('progress');
    const request = store.delete(sentenceSet);
    
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

// Ëé∑ÂèñÊâÄÊúâÂ≠òÂÇ®ÁöÑËßÜÈ¢ë
async function getAllStoredVideos() {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['videos'], 'readonly');
    const store = transaction.objectStore('videos');
    const request = store.getAll();
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// Âà†Èô§Â≠òÂÇ®ÁöÑËßÜÈ¢ë
async function deleteStoredVideo(id) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['videos'], 'readwrite');
    const store = transaction.objectStore('videos');
    const request = store.delete(id);
    
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

// Ê∏ÖÁ©∫ÊâÄÊúâÂ≠òÂÇ®ÁöÑËßÜÈ¢ë
async function clearAllStoredVideos() {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['videos'], 'readwrite');
    const store = transaction.objectStore('videos');
    const request = store.clear();
    
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

// Âè•Â≠êÈõÜÊï∞ÊçÆ
const sentenceSets = {
  '50_sentences': null,
  '150_sentences': null
};

let currentSentenceSet = '50_sentences';

// Âä†ËΩΩÂè•Â≠êÈõÜÊñá‰ª∂
async function loadSentenceFile(filename) {
  try {
    const response = await fetch(`materials/${filename}`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const text = await response.text();
    return text.split('\n').map(s => s.trim()).filter(Boolean);
  } catch (error) {
    console.error(`Âä†ËΩΩÂè•Â≠êÊñá‰ª∂Â§±Ë¥• (${filename}):`, error);
    return null;
  }
}

// Âä†ËΩΩÂè•Â≠êÈõÜ
async function loadSentenceSet() {
  const selected = el('sentenceSet').value;
  currentSentenceSet = selected;
  
  let filename;
  if (selected === '50_sentences') {
    filename = '50_sentences_list.txt';
  } else if (selected === '150_sentences') {
    filename = '150_sentences_list.txt';
  }
  
  // ‰ªéÁºìÂ≠òÊàñÊñá‰ª∂Âä†ËΩΩÂè•Â≠ê
  if (!sentenceSets[selected]) {
    sentenceSets[selected] = await loadSentenceFile(filename);
  }
  
  if (sentenceSets[selected]) {
    sentences = sentenceSets[selected];
    
    // ÊÅ¢Â§çËøõÂ∫¶
    try {
      const progress = await getProgress(selected);
      if (progress && progress.currentIndex < sentences.length) {
        idx = progress.currentIndex;
        console.log(`ÊÅ¢Â§çËøõÂ∫¶: Á¨¨${idx + 1}Âè•`);
      } else {
        idx = 0;
      }
    } catch (error) {
      console.error('ÊÅ¢Â§çËøõÂ∫¶Â§±Ë¥•:', error);
      idx = 0;
    }
    
    updateSentenceView();
  } else {
    sentences = [];
    idx = 0;
    updateSentenceView();
  }
}

// ÈáçÁΩÆËøõÂ∫¶
async function resetProgress() {
  if (!confirm('Are you sure you want to reset the recording progress for the current sentence set?')) return;
  
  try {
    await deleteProgress(currentSentenceSet);
    idx = 0;
    updateSentenceView();
    alert('Progress has been reset');
  } catch (error) {
    console.error('ÈáçÁΩÆËøõÂ∫¶Â§±Ë¥•:', error);
    alert('Failed to reset progress: ' + error.message);
  }
}

// Ê∏ÖÈô§ÊâÄÊúâËøõÂ∫¶
async function clearAllProgress() {
  if (!confirm('Are you sure you want to clear all recording progress? This action cannot be undone!')) return;
  
  try {
    const transaction = db.transaction(['progress'], 'readwrite');
    const store = transaction.objectStore('progress');
    await new Promise((resolve, reject) => {
      const request = store.clear();
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
    
    // ÈáçÁΩÆÂΩìÂâçËøõÂ∫¶
    idx = 0;
    updateSentenceView();
    alert('All progress has been cleared');
  } catch (error) {
    console.error('Ê∏ÖÈô§ËøõÂ∫¶Â§±Ë¥•:', error);
    alert('Failed to clear progress: ' + error.message);
  }
}

// ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ì
initDB().then(() => {
  console.log('IndexedDB ÂàùÂßãÂåñÊàêÂäü');
  updateStorageInfo();
  // È°µÈù¢Âä†ËΩΩÊó∂Â∞ùËØïÊÅ¢Â§çÂè•Â≠êÈõÜÈÄâÊã©
  loadSentenceSet();
}).catch(err => {
  console.error('IndexedDB ÂàùÂßãÂåñÂ§±Ë¥•:', err);
});

function updateSentenceView(){
  const total = sentences.length;
  const text = total ? sentences[idx] : '';
  el('currentText').textContent = text || 'No sentences available';
  el('idxInfo').textContent = total ? `${idx+1} / ${total}` : '';
}

el('init').onclick = async () => {
  try {
    // Ëé∑ÂèñÁî®Êà∑ÈÄâÊã©ÁöÑÂàÜËæ®Áéá
    const resolution = el('resolution').value;
    let videoConstraints = { facingMode: 'user' };
    
    // Ê†πÊçÆÈÄâÊã©ËÆæÁΩÆÂàÜËæ®Áéá
    if (resolution !== 'auto') {
      const resolutions = {
        '360p': { width: 640, height: 360 },
        '480p': { width: 854, height: 480 },
        '720p': { width: 1280, height: 720 },
        '1080p': { width: 1920, height: 1080 }
      };
      
      if (resolutions[resolution]) {
        videoConstraints = {
          ...videoConstraints,
          width: { ideal: resolutions[resolution].width },
          height: { ideal: resolutions[resolution].height }
        };
      }
    }
    
    // ÂâçÁΩÆÊëÑÂÉèÂ§¥ÔºõÂ¶ÇÈúÄÂêéÁΩÆÔºåÊää 'user' Êîπ‰∏∫ 'environment'
    stream = await navigator.mediaDevices.getUserMedia({
      video: videoConstraints,
      audio: true
    });
    
    el('preview').srcObject = stream;
    sentences = el('sentences').value
      .split('\n').map(s=>s.trim()).filter(Boolean);
    idx = 0;
    updateSentenceView();
    
    // ÊòæÁ§∫ÂÆûÈôÖËé∑ÂèñÂà∞ÁöÑÂàÜËæ®Áéá
    const videoTrack = stream.getVideoTracks()[0];
    const settings = videoTrack.getSettings();
    const actualRes = `${settings.width}√ó${settings.height}`;
    el('resolutionInfo').textContent = `Actual Resolution: ${actualRes}`;
    
    alert('Camera ready! You can start recording now.');
  } catch (e) {
    alert('Unable to access camera/microphone: ' + e);
  }
};

el('next').onclick = async () => { 
  if (sentences.length){ 
    idx = Math.min(idx+1, sentences.length-1); 
    updateSentenceView(); 
    // ‰øùÂ≠òËøõÂ∫¶
    try {
      await saveProgress(currentSentenceSet, idx);
    } catch (error) {
      console.error('‰øùÂ≠òËøõÂ∫¶Â§±Ë¥•:', error);
    }
  }
};

el('prev').onclick = async () => { 
  if (sentences.length){ 
    idx = Math.max(idx-1, 0); 
    updateSentenceView(); 
    // ‰øùÂ≠òËøõÂ∫¶
    try {
      await saveProgress(currentSentenceSet, idx);
    } catch (error) {
      console.error('‰øùÂ≠òËøõÂ∫¶Â§±Ë¥•:', error);
    }
  }
};

// Skip current sentence
el('skip').onclick = async () => {
  if (sentences.length && idx < sentences.length - 1) {
    idx++;
    updateSentenceView();
    // ‰øùÂ≠òËøõÂ∫¶
    try {
      await saveProgress(currentSentenceSet, idx);
      console.log(`Skipped to sentence ${idx + 1}`);
    } catch (error) {
      console.error('‰øùÂ≠òËøõÂ∫¶Â§±Ë¥•:', error);
    }
  } else if (idx >= sentences.length - 1) {
    alert('This is the last sentence!');
  }
};

// Redo current sentence (just stay on current sentence)
el('redo').onclick = () => {
  console.log(`Redo sentence ${idx + 1}: ${sentences[idx]}`);
  isRedo = true; // ËÆæÁΩÆÈáçÂΩïÊ†áËÆ∞
  // Just refresh the current sentence display
  updateSentenceView();
};

// ÁõëÂê¨ÂàÜËæ®ÁéáÂèòÂåñ
el('resolution').onchange = () => {
  if (stream) {
    el('resolutionInfo').textContent = 'Resolution changed, please reinitialize camera';
  }
};

// ÂàáÊç¢‰∏ãËΩΩÊ®°Âºè
function toggleDownloadMode() {
  storageMode = !storageMode;
  const button = el('downloadMode');
  if (storageMode) {
    button.textContent = 'iPad Mode: Store Locally ‚úì';
    button.style.backgroundColor = '#4CAF50';
    button.style.color = 'white';
    el('viewStored').style.display = 'inline-block';
    el('downloadAll').style.display = 'inline-block';
    el('clearAll').style.display = 'inline-block';
    el('downloadTip').textContent = 'iPad Mode: Videos will be stored locally, download later in batch';
  } else {
    button.textContent = 'iPad Mode: Store Locally';
    button.style.backgroundColor = '';
    button.style.color = '';
    el('viewStored').style.display = 'none';
    el('downloadAll').style.display = 'none';
    el('clearAll').style.display = 'none';
    el('downloadTip').textContent = 'Tip: Set a fixed download folder in Settings ‚Üí Safari ‚Üí Downloads';
  }
  updateStorageInfo();
}

// Êõ¥Êñ∞Â≠òÂÇ®‰ø°ÊÅØ
async function updateStorageInfo() {
  if (!db) return;
  
  try {
    const videos = await getAllStoredVideos();
    const count = videos.length;
    const totalSize = videos.reduce((sum, video) => sum + video.size, 0);
    const sizeInMB = (totalSize / (1024 * 1024)).toFixed(1);
    
    el('viewStored').textContent = `View Stored Videos (${count})`;
    el('storageInfo').textContent = count > 0 ? `Stored ${count} videos, ~${sizeInMB} MB` : '';
  } catch (error) {
    console.error('Êõ¥Êñ∞Â≠òÂÇ®‰ø°ÊÅØÂ§±Ë¥•:', error);
  }
}

// Êü•ÁúãÂ≠òÂÇ®ÁöÑËßÜÈ¢ë
el('viewStored').onclick = async () => {
  try {
    const videos = await getAllStoredVideos();
    if (videos.length === 0) {
      alert('ÊöÇÊó†Â≠òÂÇ®ÁöÑËßÜÈ¢ë');
      return;
    }
    
    let list = 'Â≠òÂÇ®ÁöÑËßÜÈ¢ëÂàóË°®Ôºö\n\n';
    videos.forEach((video, index) => {
      const date = new Date(video.timestamp).toLocaleString();
      const sizeMB = (video.size / (1024 * 1024)).toFixed(1);
      list += `${index + 1}. ${video.fileName}\n   Âè•Â≠ê: ${video.sentence}\n   Êó∂Èó¥: ${date}\n   Â§ßÂ∞è: ${sizeMB} MB\n\n`;
    });
    
    alert(list);
  } catch (error) {
    alert('Ëé∑ÂèñÂ≠òÂÇ®ËßÜÈ¢ëÂ§±Ë¥•: ' + error.message);
  }
};

// ‰∏ãËΩΩÊâÄÊúâÂ≠òÂÇ®ÁöÑËßÜÈ¢ë
el('downloadAll').onclick = async () => {
  try {
    const videos = await getAllStoredVideos();
    if (videos.length === 0) {
      alert('ÊöÇÊó†Â≠òÂÇ®ÁöÑËßÜÈ¢ë');
      return;
    }
    
    if (!confirm(`Á°ÆÂÆöË¶Å‰∏ãËΩΩÊâÄÊúâ ${videos.length} ‰∏™ËßÜÈ¢ëÂêóÔºü‰∏ãËΩΩÂêéÂ∞ÜËá™Âä®Ê∏ÖÈô§Â≠òÂÇ®ÁöÑËßÜÈ¢ë„ÄÇ`)) return;
    
    // ÈÄê‰∏™‰∏ãËΩΩÔºåÈó¥Èöî300ms
    for (let i = 0; i < videos.length; i++) {
      setTimeout(async () => {
        const video = videos[i];
        const a = document.createElement('a');
        a.download = video.fileName;
        a.href = URL.createObjectURL(video.blob);
        a.click();
        URL.revokeObjectURL(a.href);
        
        // ‰∏ãËΩΩÂêéÂà†Èô§ËØ•ËßÜÈ¢ë
        try {
          await deleteStoredVideo(video.id);
          console.log(`Â∑≤Âà†Èô§Â≠òÂÇ®ÁöÑËßÜÈ¢ë: ${video.fileName}`);
        } catch (error) {
          console.error(`Âà†Èô§ËßÜÈ¢ëÂ§±Ë¥•: ${video.fileName}`, error);
        }
        
        // ÊúÄÂêé‰∏Ä‰∏™ËßÜÈ¢ë‰∏ãËΩΩÂÆåÊàêÂêéÊõ¥Êñ∞Â≠òÂÇ®‰ø°ÊÅØ
        if (i === videos.length - 1) {
          setTimeout(() => {
            updateStorageInfo();
            el('storageInfo').textContent = `Â∑≤‰∏ãËΩΩ ${videos.length} ‰∏™ËßÜÈ¢ëÂπ∂Ê∏ÖÈô§Â≠òÂÇ®`;
          }, 500);
        }
      }, i * 300);
    }
    
    el('storageInfo').textContent = `Ê≠£Âú®‰∏ãËΩΩ ${videos.length} ‰∏™ËßÜÈ¢ë...`;
  } catch (error) {
    alert('‰∏ãËΩΩÂ§±Ë¥•: ' + error.message);
  }
};

// Ê∏ÖÁ©∫ÊâÄÊúâÂ≠òÂÇ®ÁöÑËßÜÈ¢ë
el('clearAll').onclick = async () => {
  try {
    const videos = await getAllStoredVideos();
    if (videos.length === 0) {
      alert('ÊöÇÊó†Â≠òÂÇ®ÁöÑËßÜÈ¢ë');
      return;
    }
    
    if (!confirm(`Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâ ${videos.length} ‰∏™Â≠òÂÇ®ÁöÑËßÜÈ¢ëÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§çÔºÅ`)) return;
    
    await clearAllStoredVideos();
    updateStorageInfo();
    alert('Â∑≤Ê∏ÖÁ©∫ÊâÄÊúâÂ≠òÂÇ®ÁöÑËßÜÈ¢ë');
  } catch (error) {
    alert('Ê∏ÖÁ©∫Â§±Ë¥•: ' + error.message);
  }
};

el('start').onclick = () => {
  if (!stream) return alert('Please initialize camera first!');
  if (recording) return;
  chunks = [];
  
  // ÈªòËÆ§‰ΩøÁî®MP4Ê†ºÂºè
  const mp4Options = [
    'video/mp4;codecs=h264,aac',
    'video/mp4;codecs=avc1.42E01E,mp4a.40.2',
    'video/mp4'
  ];
  const mimeType = mp4Options.find(type => MediaRecorder.isTypeSupported(type)) || 'video/webm;codecs=vp9,opus';
  
  mediaRecorder = new MediaRecorder(stream, { mimeType });
  mediaRecorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
  mediaRecorder.onstop = saveBlob;
  mediaRecorder.start();
  recording = true;
  
  // ÊòæÁ§∫ÂΩïÂà∂Áä∂ÊÄÅ
  el('recordingStatus').style.display = 'block';
  el('start').style.opacity = '0.5';
  el('stop').style.opacity = '1';
};

el('stop').onclick = () => {
  if (mediaRecorder && recording) {
    mediaRecorder.stop();
    recording = false;
    
    // ÈöêËóèÂΩïÂà∂Áä∂ÊÄÅ
    el('recordingStatus').style.display = 'none';
    el('start').style.opacity = '1';
    el('stop').style.opacity = '0.5';
  }
};

// Ê∑ªÂä†Á©∫Ê†ºÈîÆÂø´Êç∑ÈîÆÊîØÊåÅ
document.addEventListener('keydown', (event) => {
  // Âè™Âú®Á©∫Ê†ºÈîÆÊåâ‰∏ã‰∏îÊ≤°ÊúâËÅöÁÑ¶Âú®ËæìÂÖ•ÂÖÉÁ¥†Êó∂Ëß¶Âèë
  if (event.code === 'Space' && !['INPUT', 'TEXTAREA', 'SELECT'].includes(event.target.tagName)) {
    event.preventDefault(); // Èò≤Ê≠¢È°µÈù¢ÊªöÂä®
    
    if (!recording) {
      // ÂºÄÂßãÂΩïÂà∂
      el('start').click();
    } else {
      // ÂÅúÊ≠¢ÂΩïÂà∂
      el('stop').click();
    }
  }
});

function sanitize(s){
  return s.replace(/[\\/:*?"<>|]/g,'').replace(/\s+/g,' ').trim();
}
function ts(){
  const d = new Date();
  const pad = n => String(n).padStart(2,'0');
  return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
}
async function saveBlob(){
  // Ê†πÊçÆÂÆûÈôÖ‰ΩøÁî®ÁöÑmimeTypeÁ°ÆÂÆöÊñá‰ª∂Êâ©Â±ïÂêç
  const isMP4 = mediaRecorder.mimeType.includes('mp4');
  const fileExt = isMP4 ? 'mp4' : 'webm';
  const blobType = isMP4 ? 'video/mp4' : 'video/webm';
  
  const blob = new Blob(chunks, { type: blobType });
  const sentence = sentences[idx] ? sanitize(sentences[idx]) : 'unknown_sentence';
  const timestamp = ts();
  const redoSuffix = isRedo ? '_redo' : '';
  const fileName = `${sentence}_${timestamp}${redoSuffix}.mp4`; // ÂßãÁªà‰ΩøÁî®mp4Êâ©Â±ïÂêç
  
  if (storageMode) {
    // iPadÊ®°ÂºèÔºöÂ≠òÂÇ®Âà∞IndexedDB
    try {
      await storeVideo(blob, fileName, sentences[idx] || 'Êú™Áü•Âè•Â≠ê', currentSentenceSet, idx);
      updateStorageInfo();
      el('storageInfo').textContent = `ËßÜÈ¢ëÂ∑≤Â≠òÂÇ®: ${fileName}`;
      console.log(`ËßÜÈ¢ëÂ∑≤Â≠òÂÇ®Âà∞Êú¨Âú∞: ${fileName}`);
    } catch (error) {
      console.error('Â≠òÂÇ®ËßÜÈ¢ëÂ§±Ë¥•:', error);
      alert('Â≠òÂÇ®ËßÜÈ¢ëÂ§±Ë¥•: ' + error.message);
      // Â§±Ë¥•Êó∂ÂõûÈÄÄÂà∞Áõ¥Êé•‰∏ãËΩΩ
      directDownload(blob, fileName);
    }
  } else {
    // ÊôÆÈÄöÊ®°ÂºèÔºöÁõ¥Êé•‰∏ãËΩΩ
    directDownload(blob, fileName);
  }
  
  // ÂΩïÂà∂ÂÆåÊàêÂêéËá™Âä®Ë∑≥Âà∞‰∏ã‰∏ÄÂè•ÔºàÂ¶ÇÊûú‰∏çÊòØÊúÄÂêé‰∏ÄÂè•Ôºâ
  if (idx < sentences.length - 1) {
    idx++;
    updateSentenceView();
    
    // ‰øùÂ≠òËøõÂ∫¶
    try {
      await saveProgress(currentSentenceSet, idx);
      console.log(`Ëá™Âä®ËøõÂÖ•‰∏ã‰∏ÄÂè•: Á¨¨${idx + 1}Âè•`);
    } catch (error) {
      console.error('‰øùÂ≠òËøõÂ∫¶Â§±Ë¥•:', error);
    }
  } else {
    // Â∑≤ÂÆåÊàêÊâÄÊúâÂè•Â≠ê
    alert(`Congratulations! You have completed recording all ${sentences.length} sentences!`);
  }
  
  // ÊòæÁ§∫Ê†ºÂºè‰ø°ÊÅØ
  console.log(`ÂΩïÂà∂ÂÆåÊàêÔºåÊ†ºÂºè: ${fileExt.toUpperCase()}, MIMEÁ±ªÂûã: ${mediaRecorder.mimeType}`);
}

function directDownload(blob, fileName) {
  const a = document.createElement('a');
  a.download = fileName;
  a.href = URL.createObjectURL(blob);
  a.click();
  URL.revokeObjectURL(a.href);
}
</script>
</body>
</html>